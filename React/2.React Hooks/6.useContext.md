## useContext Hook
- In React Applications, sometimes managing state across deeply nested components can become very difficult. The useContext hook offers a simple and efficient solution to share state between components without the need for prop drilling.

**What is useContext Hook?**
The useContext hook in React allows components to consume values from the React context. React’s context API is primarily designed to pass data down the component tree without manually passing props at every level. useContext is a part of React's hooks system, introduced in React 16.8, that enables functional components to access context values.

It helps avoid the problem of "prop drilling," where props are passed down multiple levels from parent to child components.

Simplifies accessing shared state across components.
Avoids prop drilling by eliminating the need to pass props down multiple levels.
Works seamlessly with React's Context API to provide global state.
Ideal for managing themes, authentication, or user preferences across the app

- Syntax
const contextValue = useContext(MyContext);
. MyContext: The context object is created using React.createContext().
. contextValue: The current context value that we can use in our component.

**How does it work?**
- The useContext hook allows to consume values from a React Context, enabling easy access to shared state across multiple components without prop drilling. Here’s how it works:

- useContext hook consumes values from a React Context, making them accessible to functional components.
- First, create a Context object using React.createContext(), which holds the shared state.
- Use useContext to access the context value in any component that needs it, avoiding prop drilling.
- When the value of the Context updates, all components consuming that context automatically re-render with the new value.

**Creating a Context**
- Before using useContext, we need to create a context using React.createContext(). This context will provide a value that can be accessed by any child component wrapped in a Context.Provider.

import React, { createContext, useContext, useState } from 'react';

const MyContext = createContext();

function App() {
    const [value, setValue] = useState('Hello, World!');

    return (
        <MyContext.Provider value={value}>
            <ChildComponent />
        </MyContext.Provider>
    );
}

function ChildComponent() {
    const contextValue = useContext(MyContext);
    return <h1>{contextValue}</h1>;
}

. createContext() creates a context object (MyContext) that holds a default value.
. MyContext.Provider passes down the context value to its child components.
. useContext(MyContext) allows components like ChildComponent to access the context value.

**Implementing the useContext Hook**

1. Managing Authentication with useContext:

- useContext can be used for managing the user authentication state globally.

import React, { createContext, useContext, useState } from 'react';
const AuthContext = createContext();
function AuthProvider({ children }) {
    const [isLoggedIn, setIsLoggedIn] = useState(false);
    return (
        <AuthContext.Provider value={{ isLoggedIn, setIsLoggedIn }}>
            {children}
        </AuthContext.Provider>
    );
}
function LoginButton() {
    const { isLoggedIn, setIsLoggedIn } = useContext(AuthContext);
    return (
        <button onClick={() => setIsLoggedIn(!isLoggedIn)}>
            {isLoggedIn ? 'Logout' : 'Login'}
        </button>
    );
}
function App() {
    return (
        <AuthProvider>
            <LoginButton />
        </AuthProvider>
    );
}
export default App;

- In this example
. AuthContext is created using createContext() and AuthProvider manages the isLoggedIn state, passing it down through the context.
. LoginButton uses useContext to access isLoggedIn and setIsLoggedIn from the context and toggles the login state.
. App renders LoginButton wrapped in AuthProvider, allowing dynamic login/logout functionality.

2. Sharing a Theme Across Components:

- We will create a theme context and use useContext to access its values in child components.


import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();
function ThemeProvider({ children }) {
    const [theme, setTheme] = useState('light');

    const toggleTheme = () => {
        setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            {children}
        </ThemeContext.Provider>
    );
}
function ThemedComponent() {
    const { theme, toggleTheme } = useContext(ThemeContext);
    return (
        <div style={{ background: theme === 'light' ? '#fff' : '#333', 
            color: theme === 'light' ? '#000' : '#fff', padding: '20px', textAlign: 'center' }}>
            <p>Current Theme: {theme}</p>
            <button onClick={toggleTheme}>Toggle Theme</button>
        </div>
    );
}
function App() {
    return (
        <ThemeProvider>
            <ThemedComponent />
        </ThemeProvider>
    );
}

export default App;

- In this example

. ThemeContext is created using createContext().
. ThemeProvider manages the theme state and provides a toggleTheme function.
. useContext(ThemeContext) in ThemedComponent allows access to the current theme and the ability to toggle it.
. Clicking the button switches between light and dark themes.


**When to Use useContext**
- We can use the useContext when:
. We need global state management for themes, authentication, or user preferences.
. We want to avoid prop drilling.
. We need state sharing between multiple components without a third-party state management library.
